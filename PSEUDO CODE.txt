
TODO
1) QUEUE
2) SWITCH IN websites


@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def _packet_in_handler(self, ev):
        if ev.msg.msg_len < ev.msg.total_len:
            self.logger.debug("packet truncated: only %s of %s bytes",
                              ev.msg.msg_len, ev.msg.total_len)
        msg = ev.msg
        datapath = msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        in_port = msg.match['in_port']
        dpid = datapath.id
        

        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocols(ethernet.ethernet)[0]
        pkt_eth = pkt.get_protocol(ethernet.ethernet)

        # Check if the packet is an LLDP packet
        if eth.ethertype ==  ether_types.ETH_TYPE_LLDP:
            lldp_pkt = pkt.get_protocol(lldp.lldp)

            # Check if the LLDP packet indicates a down link
            if lldp_pkt.tlvs[0].subtype == lldp.ChassisID.SUB_LOCALLY_ASSIGNED and \
                    lldp_pkt.tlvs[1].subtype == lldp.PortID.SUB_LOCALLY_ASSIGNED and \
                    lldp_pkt.tlvs[1].chassis_id == self.CHASSIS_ID:

                port_no = lldp_pkt.tlvs[1].port_id
                dst_mac = self.port_to_mac[(datapath.id, port_no)]

                # Remove flow entries associated with the down link
                self.delete_flow(datapath)
        
        if pkt_eth:

            dst_mac = pkt_eth.dst
            eth_type = pkt_eth.ethertype
        
        
        pkt_tcp = pkt.get_protocol(tcp.tcp)
        if pkt_tcp:
            
            ip_header = pkt.get_protocol(ipv4.ipv4)
            src_ip = ip_header.src
            dst_ip = ip_header.dst
            # src_port = tcp_header.src_port
            # dst_port = tcp_header.dst_port
            # seq_num = tcp_header.seq
            print(ip_header)
            print(f'TCP packet received: {src_ip}:-> {dst_ip}')
        
        
        pkt_arp = pkt.get_protocol(arp.arp)
        if pkt_arp:
            if str(pkt_arp.dst_mac) != "00:00:00:00:00:00":
                print ("datapath id: "+str(dpid))
                print ("port: "+str(in_port))
                print ("pkt_eth.dst: " + str(pkt_eth.dst))
                print ("pkt_eth.src: " + str(pkt_eth.src))
                print ("pkt_arp: " + str(pkt_arp))
                print ("pkt_arp:src_ip: " + str(pkt_arp.src_ip))
                print ("pkt_arp:dst_ip: " + str(pkt_arp.dst_ip))
                print ("pkt_arp:src_mac: " + str(pkt_arp.src_mac))
                print ("pkt_arp:dst_mac: " + str(pkt_arp.dst_mac))
                adj_list = to_dict_of_lists(self.topology)

                # Print the adjacency list
                for node, neighbors in adj_list.items():
                    print(f"{node}: {neighbors}")
                print("Shortest path from " + str(pkt_arp.src_mac) + " to "+ str(pkt_arp.dst_mac)+" : " )
                self.get_shortest_path(str(pkt_arp.src_mac),str(pkt_arp.dst_mac), self.topology)
        
        dst = eth.dst
        src = eth.src

        self.mac_to_port.setdefault(dpid, {})

        self.mac_to_port[dpid][src] = in_port

        if dst in self.mac_to_port[dpid]:
            out_port = self.mac_to_port[dpid][dst]
        else:
            out_port = ofproto.OFPP_FLOOD

        actions = [parser.OFPActionOutput(out_port)]

        # install a flow to avoid packet_in next time
        if out_port != ofproto.OFPP_FLOOD:
            match = parser.OFPMatch(in_port=in_port, eth_dst=dst)
            # verify if we have a valid buffer_id, if yes avoid to send both
            # flow_mod & packet_out
            if msg.buffer_id != ofproto.OFP_NO_BUFFER:
                self.add_flow(datapath, 1, match, actions, msg.buffer_id)
                return
            else:
                self.add_flow(datapath, 1, match, actions)
        data = None
        if msg.buffer_id == ofproto.OFP_NO_BUFFER:
            data = msg.data

        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                  in_port=in_port, actions=actions, data=data)
        datapath.send_msg(out)
